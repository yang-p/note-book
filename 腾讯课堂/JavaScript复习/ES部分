只有字符串的比较，才是比较的ascll码顺序。
NaN不等于任何数，包括它本身。

switch case 的缺陷，当满足一个case条件后，任然会执行后面的case语句，所以需要给每个case语句加上break。 
break只能用于循环语句中，当然也可以放在循环语句中的判断语句中。
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————
类型转换
	显示转换:
			Number() 除了null和纯数字的字符串，其他都是NaN
			parseInt( , radix)  以当前radix为基底转换成10进制
			.toString(radix) undefined和null没有该方法，将目标转换成当前进制数。

	隐式类型转换：
			除了加号有两种作用外，其他的算术运算符都是隐式的转换成NUmber类型。
			undefined == null 

	typeof可以使未声明且未赋值的东西不报错，并且这也是这种东西唯一不报错的地方。

———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
闭包的缺点：
			原有的作用域链不释放，造成内存泄漏。
闭包的作用：
			属性私有化、模块化开发，防止污染全局变量、
			函数累加器(一个函数里面有count变量，然后return一个子函数到全局，然后执行该函数，每执行一次就会累加一次count)。

立即执行函数：
				任何算式都是表达式，函数表达式后面加执行符号，就可以当做立即执行函数。

				当一个函数声明变成表达式时，其函数名就不再指向该函数体，而是undefined，比如给函数声明外面加一个括号就变成了表达式。

包装类：
		基本类型数据中undefined和null没有包装类，基本类型的数据没有属性和方法，如果一定要操作这些属性和方法，那么系统并不会报错，也不会执行，
		因为系统会隐式的用new实例化一个对象，目的是尽可能不报错，然后立即delete掉。当再次操作该基本类型的属性时，又会重新new一个对象。


构造函数每次创建一个对象时，都会产生一个新的执行期上下文，所以如果构造函数形成闭包，那么不同对象之间不是共用一个作用域链。

原型：
		原型是function对象的属性，该属性的值是一个对象地址，简称原型而是一个对象，这个对象是该构造函数构造出来的对象的公共祖先。

		对象查看原型的方法：__proto__, 该属性是构造函数创建对象时，隐式创建this对象时，this对象的系统内部属性，属性值为原型，
							构造函数构造出来的对象可以更改原型的指向。
							原型对象上也有__proto__属性，此时就构成原型链。

		对象查看自己的构造函数的方法: constructor (该属性在原型上)。

		Object.create(原型);  例子: obj = Object.create(obj1); obj对象的原型指向obj1对象。
		注意点： 由于Object.create()的括号里面只能放原型或null，所以当括号里面为null时，obj就没有原型了，
				 所以不是所有的对象的终端原型都是Object.prototype。


枚举：	for(var prop in obj) {}  当遍历时，obj的属性会赋给prop变量。
		for-in循环 不需要知道对象和数组的长度，就能遍历对象和数组中的属性，并且对象没有长度，所以for循环不适合遍历对象。
		注意点：使用forin循环遍历查看一个对象属性时，极易出现问题，因为我们喜欢写成obj.prop，然而系统内部时要将‘点’这种
				写法转换成‘方括号’的写法。obj['prop'] ,但是对象里面没有prop属性啊，所以返回undefined。

hasOwnProperty() 由于在遍历一个对象属性的时候，会把对象的原型上的属性和方法遍历出来，所以用该方法判断，当为ture时，该属性是
				 自己对象的或自定义__proto__的，为false时，该属性是系统规定的该对象的原型上的属性。	
				 注意点：该方法和枚举方法一般情况下一起出现。


判断一个变量是数组还是对象：
						 A instant of B  判断A对象是否是构造函数构造出来的。 利用的是原型上的constructor属性，但是由于原型链的原因
						 				A对象也可以是Object函数构造出来的。
						 Object原型上的toString方法   其他构造函数的原型上也有toString方法，他们都是用的Object原型上的toString，
						 							  所以这叫方法的重写，但是要用Object的原型上的toSting方法才能判断数组和对象。
						 							  但是其他对象调用它时应用call或apply方法。Object.prototype.toString.call(目标对象)


一个括号里面如果有两个数，并且是用逗号隔开的，那么会返回逗号后面那么数。
同时，如果一个括号里面用很多函数，只能用逗号隔开，因此只会执行最后一个函数。



this的指向问题：
				1.预编译过程，函数的执行器上下文AO对象中的this属性，指向window。
				 但是当该函数创建对象时，函数里面的this = Objetc.create(函数名.prototype)

				2. 全局作用域里面使用this，该this指向window，其实质是test()系统内部会test.call()
				3. call和apply改变this指向
				4. 谁调用该方法，那么该方法里面的this就指向谁。

____________________________________________________________________________

数组：
		字面量数组形式和构造函数创建出的数组的唯一区别： new Array()括号里面有且仅有一位正整数时代表数组长度。	

数组的方法：
			改变原数组：
			push添加  向数组的第length位添加数，push方法一次性可以添加多个数，用逗号隔开。
			unshift添加 向数组的第0位之前添加，一次性可以添加多个数	
			pop剪切  删除第length-1位数，并且只能删除一个，不能同时删除多个
			shift剪切 删除数组的第0个数。
			splice(从第几位开始切，切的长度，添加到新的切口的数据)
			reverse 将原数组倒叙
			sort升序、降序、乱序(升序和降序的结合) arr.sort = function (a,b){return .....;	}

			不改变原数组，但是生成新的副本：

			concat  arr.concat(arr1) 两个数组拼在一起生成新的数组，arr的值在前面。
			toString 将数组的值转换成字符串，每一个值之间用逗号隔开。
			slice(从第几位开始截取， 从第几位结束截取) 如果没有说明从哪位结束截取，那么就是从开始位到最后一位。
														如果开始和结束位都没有说明，那么是剪切整个数组。

			str.split('') 将字符串按照字符串的某个分隔符进行分割，然后放在数组里面，分隔符不会放在数组里。	
			arr.join('') 将数组的值按照自定义的分隔符拼接成一个字符串。
——————————————————————————————————————————————————————————————————————————————————————————————————
类数组:
		属性为索引属性，必须有length属性，最好是还有push方法
		var obj = {
			'0': 0,
			'1': 1,
			length: 2,
			push: Array.prototype.push
		}
		Array.prototype.push = functtion(target){
				this[this.length] = target;
				this.length ++;
		}
		从push方法的实现原理，可以看出，向类数组push属性的时候，push到哪个位置由该类数组的length属性决定。

________________________________________________________