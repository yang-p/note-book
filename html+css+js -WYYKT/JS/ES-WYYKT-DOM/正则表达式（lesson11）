‘\’转义字符，将该转义字符后面紧跟着的一位字符转换成文本。将该转义字符转换为文本。

‘\’跟特定的字符会有特定的功能:
     '\n'  代表换行
     ‘\r’代表一行结束，在Windows系统中，当人为换行时系统内部执行 \r\n
     ‘\t’制表符（t全称table），让该转义字符的左右两边产生默认四个空格的距离。

————————————————————————————————————————————————————————————
正则表达式(RegExp)的作用:匹配特殊字符，或有特殊搭配原则的字符，的最佳选择。

正则表达式的两种创建方式：
       方法一：字面量方式创建
                var reg = /在这里放不加引号的字符/在这里写修饰符
       方法二：构造函数new创建
                var reg = new RegExp("字符","修饰符");
                var reg1 = new RegExp(reg2);//reg2是一个引用值，代表另一个正则表达式，
                        //reg1和reg2虽然内容一样，但却不是同一个正则表达式。
                var reg1 = RegExp(reg2); //reg1和reg2指向同一个正则表达式，但是这种写法不建议用。

————————————————————————————————————————————————————————————
正则表达式修饰符：
       下面三个修饰符可以同时写在一起，如igm、img等。
               i   忽略匹配时的大小写，没有i表示区分大小写
   比如 var reg = /ab/i ; var str = 'ABCD';  ———> reg.test(str)———> true
               g   全局匹配，没有g，则只返回第一个匹配到的片段
   比如 var reg = /ab/g; var str = 'abababab' —> str.match(reg)———> ['ab','ab',‘ab’,'ab']，匹配不成功则返回null
              m   执行多行匹配
   比如:var reg = /^a/m;var str = 'abc\na'; ——> str.match(reg);
   前面的正则表达式代表匹配以a字母开头的字符串，如果没有m修饰符， 它不会认为\n后面的a是下一行的，
   但是加了m修饰符，会认为\n后面的a是下一行的，并且还是下一行的开头。

————————————————————————————————————————————————————————————

正则表达式的方法：
    reg.test(str);测试reg中的内容是否为字符串中的一个片段，返回结果为Boolean值。

    reg.exec(str); 和lastIndex属性配合使用。lastIndex表示当前光标的位置。
                          例如： var reg = /abcde/g;   var str = "abcdeabcde";
                                 当执行 reg.exec(str)后，lastIndex从0变成5，因为未执行前，光标在首字母a前面，
                                 执行后，光标向右移动了5位，即移动了一个片段的长度，
                                 当再次执行时，lastIndex从5变成10，原理一样，
                                 当再再一次执行时，由于后面是一个逻辑空白，所以返回的是空串，而lastIndex又回到了0.
                                 当又一次执行时，就相当于第一次执行了，lastIndex从0又变成了5.
                          但是当 reg = /abcde/;此时没有了g属性。那么无论执行多少次，lastIndex始终为0。
                          若表达式里面还有子表达式，即将表达式放在小括号里面，返回的类数组中会有子表达式匹配到的内容。

          知识拓展：
                   要想匹配如"aaaa"的形式，var reg = /(\w)\1\1\1/  小括号里面的内容称为子表达式。
                   \1表示复制第一个子表达式匹配到的字符(这里匹配到的是字符a)，一个\1代表复制一次。
                   要想匹配如"aabb"的形式，var reg = /(\w)\1(\w)\2/
                   \2表示复制第二个子表达式匹配到的字符(第二个子表达式匹配到的是字符b)，一个\2代表复制一次。
                   要想使一串数字每隔三位打个点，如100.000.000；
                   var str = 100000000;
                   var reg = /(?=(\B)(\d{3}+$))/g;在逻辑空白处实现打点，从最后开始匹配逻辑空白，并且该逻辑空白的特性是
                               后面隔三的倍数位数字，并且逻辑空白不能为单词边界。
                   str.replace(reg, '.');

字符串的方法：
            str.match(reg); 和exec()方法一样，返回的都是同样的东西，区别是当reg中有g属性时，只返回匹配的片段。
            str.search(reg); 匹配成功返回第一个片段的第一个字符前面的逻辑空白的下标值，无论执行多少次，
                             都只返回匹配到的第一个片段的... ,当匹配失败时返回-1得错误信息。
            str.toUpperCase() 将一个字符转换成大写。
            str.toLowerCase() 将一个字符转换成小写。
            str.replace()   将一个字符串替换为另一个字符串。
            但是有注意点： var str = "aa";
               当不用正则表达式时：str.repalce(str,'b'); 结果为 str = ‘ba’没有能力访问全局字符串，只能替换第一个字符。
               当用正则表达式但不用g属性时：str.replace(reg,'b') 结果为 str = 'ba'。
               当用正则表达式并且用g属性时：str.replace(reg,'b') 结果为 str = 'bb'。

            拓展：将"abab"倒过来成"baba"
                   var str = "abab";
                   var reg = /(\w)(\w)\1\2/g;
                   str.replace(reg,"$2$1$2$1"); $代表reg中的引用子表达式匹配的内容。
               str.replace(reg, function($,$1,$2){ //形参$表示第0个子表达式，正则表达式中有多少个子表达式就给多少形参。
                return $2+$1+$2+$1;  【reg执行多少次看有没有g属性，function(){}执行多少次看reg】
               })这种写法和sort方法类似，当自己添加形参时，系统会传值进来。

            该写法的一个拓展：让字符串"the-first-name"变成小驼峰式。
                              var str = "the-first-name";
                              var reg = /-(\w)/g;
                              str.replace(reg, function ($,$1) {
                              return $1.toUpperCase();
                              })
————————————————————————————————————————————————————————————
正则表达式的规则：
      [] ,该符号称为表达式，它代表一个字符，里面可以放任何内容，该内容代表匹配的区间，
          写几个中括号代表几个连在一起的字符，如var reg = /[][][]/

      区间的简便写法:
                    [0-9] 查找0到9之间的任意数字
                    [A-Z] 查找ascall代码中的从A到Z的任意字符
                    [a-z] 查找ascall代码中的从a到z的任意字符
                    [A-z] 查找ascall代码中的从A到z的任意字符
                    [0-9A-Z]、[0-9A-Za-z]、[A-Za-z]....这些写法都合法

      [^],称为非，和逻辑运算符中的非用法一样，而在中括号外面的‘^’代表匹配字符串的第一个字符。
           例如：[^a],表示查找只要不是字符a的任意字符。
      (|),称为或，和逻辑运算符中的或用法一样，例如(a|b),表示查找字符a或字符b。
————————————————————————————————————————————————————————————
正则表达式的元字符：
          一个正则表达式里面可以同时写多个元字符，如 var reg = /\w\d\s\s\s..../
       \w,  /\w/ === /[0-9A-z_]/        \w代表一个字符，区间为0-9A-z_ ,这里的下划线不要漏了。
             例如：var reg = /\wabc/g; var str = '1abc'; str.match(reg) === '1abc'。
       \W,  /\W/ === /[^\w]/      \W的区间和\w互补，一般指中英文符号和特殊符号。

       \d，/\d/ === /[0-9]/  区间为数字字符
       \D  \D === [^\d]      区间为非数字的字符

       \s, /\s/ === /[\t\r\n\v\c]/ 匹配空白字符(换行、空格、)
       \S, /\S/ === /[^\s]/       匹配非空白字符

       \b, /\b/ === 单词边界    单词边界:一个单词左右两边都有空白，这个空白称为边界。
                              例如 "abc",这是一个单词，两个边界； "abc bcd",这是两个单词，四个边界
       \B, 非单词边界

       \n ，\t ,\r,\v,\f  后三个一般用不到，一般用\s代替他们所有。  在匹配时，字符串里面也需要相应的转义字符才能识别。
                var reg =/\tc/;var str = 'ab c';  str.match(reg);返回null;当str = "ab\tc"，返回‘  c’。

       \U,\u   Unicode编码，以分层的形式对应不同的字符，共16层
                \u010000 - \u00ffff 前两位数代表层数，此时是第一层，也可以是00，当为10时，为第十六层。
                                    后四位代表16进制数。每一层都是从0000到ffff。
                \u0000 - \uffff  只有四位数时，表示从第一层的0000到十六层的ffff。————> reg = /[\u0000-\uffff]/
                \uXXXXXX，只代表一个字符，该字符可以是汉字也可以是其他的任意字符。

       . 一个点，代表除了\r和\n的所有字符；/./ === /[^\r\n]/   当字符串里面有\r或\n，返回的是空格字符串形式。
————————————————————————————————————————————————————————————
量词：
     n+  区间{1，infinity} n代表一个元字符，+代表一个1到正无穷的数；
         如：var reg = /\w+/;var str = "abc"; 字符a合格，继续匹配下个字符，此时+为3.

     n*  区间{0,infinity}和上面的类似，其中匹配规则为贪婪原则，所以优先匹配字符，而不是字符前面的光标位置。
            由于*的区间是从0开始，所以要考虑当匹配到的字符不合格时，逻辑空白的影响。
            特别是一个字符串结束时的那个逻辑空白。比如字符串"abc"，用/\w*/g匹配——>返回["abc"," "]

      贪婪原则:比如字符串“abc”当abc这三个字符都能匹配上，那么直接返回[‘abc’],而不是一个个字符返回。
      光标所在的位置称为逻辑空白。
      非贪婪原则：在量词后面加一个问号'?'

     n?  区间{0,1}

     n{x} x为一个具体的数字，比如x为3时，就是三个字符为一组进行匹配。

     n{x,y} 从x到y的一个范围，若y不写n{x,}那么代表区间为x到正无穷，遵循贪婪原则。

     ^n    以n为开头
     n$   以n为结尾
     ^n$   以n开头并且以开头的那个n结尾,起到限定字符串的作用， 如"abcabc".match(/^abc$/) 返回null

————————————————————————————————————————————————————————————
正向预查(正向断言)：
            ?=n       一个字符串"abaaa"   寻找后面跟着字符b的字符a。   var reg = /a(?=b)/g; 只返回一个字符“a”
            ?!n       一个字符串"abaaa"   寻找后面没有跟着字符b的字符a。   var reg = /a(?=b)/g; 返回3个字符“a”
————————————————————————————————————————————————————————————
注意点：当匹配字符串中的如‘？’、‘\’、'*'等字符时，由于它们在正则表达式中能产生效果，所以需要在它们前面加转义字符‘\’。
        var reg = /(\w)\1*/ 这种在\1后面加量词，就能实现对形如“aaabbbbcccccc”的字符串进行简单去重。

