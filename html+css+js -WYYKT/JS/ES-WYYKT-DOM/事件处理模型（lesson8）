事件冒泡：
在结构上(非视觉上)嵌套的元素，会存在事件冒泡功能，即同一个事件事件源的子元素会冒泡向父代元素(自底向上)
事件捕获：
在结构上(非视觉上)嵌套的元素，会存在事件捕获功能，即同一个事件从父代元素会捕获至事件源的子元素(自顶向下)

注意点:IE没有捕获功能，并且除了Chrome，其他浏览器的旧版本也没有，新版有捕获功能是因为涉及到了Chrome的webkit内核。
触发顺序：先捕获再冒泡
    捕获的写法：dom.addEventListenner(事件类型，处理函数，ture)
    冒泡的写法：dom.addEventListenner(事件类型，处理函数，fasle)

不具备冒泡的事件：focus(聚焦)、blur()、change、submit、reset、select。
总结：不是所有事件都会冒泡。

   在解决元素拖拽问题时也涉及到另一个“捕获”，为元素设置一个鼠标事件，当鼠标离开该元素，事件就失效了，两种解决办法，
   第一种鼠标移动事件放在document元素上，无论鼠标怎么移动该事件都不会失效。
                 第二种就是“捕获”事件了，但是只有IE能用，为目标元素dom添加setCaputure()方法，无论鼠标在哪儿，
                 它都会捕获过来，所以为了不干扰其他元素的执行，还需要加上releaseCapture()方法。
————————————————————————————————————————————————————————————
取消事件的冒泡：
     方法①：事件对象.stopPropagation();   W3C官方标准，IE9及以下不支持
     事件对象：
       在每个事件处理函数里面写一个形参，这个形参对我们来说没用，但是系统会自动传递一个事件对象给形参，
       这个事件对象里面有很多属性，每一个属性都记载了事件发生时的关键性数据，同时该对象里面还有
       一个stopPropagation方法，该方法是用来取消冒泡事件。
     方法②：事件对象.cancelBubble = true; IE独有的一个属性。(现在的Chrome也支持)

取消浏览中的默认事件：
      方法①：在处理函数的后面加上 return false;//兼容性非常好，但只有句柄绑定能使用。
       注意点：该方法只能用于句柄事件，否则无效。比如： dom.onclick = function(){}
      方法②：event.preventDefault();//W3C官方标准，IE9及以下不支持
        注意点：该方法来也来自同一个事件对象，并且只针对非IE浏览器，
                对IE来说，事件发生时的数据保存在window对象的event属性中，所以在处理函数中需要添加一句
                var event = e || window.event//e代表保存事件发生时存储数据的那个对象。(只有在全局时，window可以省略不写)
      方法③：event.returnValue = false;//兼容IE

      a标签的跳转功能就是一个默认事件，可以通过方法①去掉，
      也可以这样：<a href = "script:void(false)"></a>//void相当于return，里面的值只要让boolean值为假就行。
————————————————————————————————————————————————————————————
事件源对象 ：是事件对象中的其中一个属性。比如点击事件，它记录了鼠标点击的位置，返回的是某个元素，
             该元素后面接的是能唯一标识这个元素的选择器。
获取事件源对象的方法：
           event.target       firefox只有这个方法
           event.srcElement   IE只有这个方法
           这两个方法Chrome浏览器都支持。
           在获取事件源对象时，考虑兼容性，应写为  var event = event.target || event.srcElement;
————————————————————————————————————————————————————————————
事件委托：
      利用事件冒泡、事件源对象进行处理
      优点：
           1.性能方面，不需要循环所有的元素，一个个绑定事件。
           2.灵活，当有新的子元素时，不需要再为新子元素绑定事件。
      例如：一个ul元素里面有无数个li元素，li元素的内容为该元素所在的顺序数字，当点击某个li元素，实现打印该li元素的数字。
      实现：在ul上面写一个onclick事件，由于点击li元素会冒泡到ul元素，所以触发了ul的点击事件的处理函数，
            而在处理函数中写上获取事件源对象的方法。





