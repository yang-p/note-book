对象的两种类型： 主机的(浏览器环境)windows对象、 所有的DOM对象
                 原生的(ECMAscript标准)内置对象(数组、日期对象等)、 用户自定义对象( 例如 var obj = {})
_______________________________________________________________________________________________________________________
对象的创建
          字面量形式对象创建：var obj = {}   相当于系统内部 var obj = new Object();
          构造函数创建：系统自带的构造函数：var obj = new Object();
                        自定义构造函数：function Test() {}    var  test = new Test();

           构造函数和普通函数没啥区别，构造函数名用大驼峰式，
           用new关键字连接一个‘函数执行’，代表该函数为构造函数，并且会创建出该函数的一个对象，
           每次使用new加‘函数执行'创建对象时都会执行一次该函数,所以创建的对象是独一无二的。
           (创建的多个对象，虽然都是用构造函数的作用域链，但不会共享，只有一个对象，执行对象中的方法时，
           会产生一种共享效果，其实质是共享的是这个对象的作用域链，而作用域链中又保存了该构造函数的AO对象)

 属性的增删改查：
                查看   一个对象没有该属性时，返回undefined。
                删除    delete 对象.属性； 若该属性在对象中不存在，当访问这个属性时，那么会返回undefined
 属性值可以是任意类型的，对象中的函数称为方法，在方法内部使用对象的属性时，需要用到this关键字。
           【因为他们的最终原型都是object】

构造函数内部原理三部曲：
                 ①在函数体顶部隐式的创建 var this = {};相当于在该函数的AO中添加了{ this : {}, }
                   【前提必须是用new关键字声明的函数，当用new声明时系统才会隐式创建this对象】
                 ②执行this.XXX = xxx;   在this这个对象中添加属性和方法。
                 ③隐式的返回this;       第二步执行完后，内部隐式的创建一个 return this；
                 【拓展】可以显式的更改return 的返回值;当返回值是一个引用类型，系统会以返回它，
                         但是如果返回值是原始类型，那么  系统会忽略原始值并强制的返回this对象。
————————————————————————————————————————————————————————————
包装类
        原始类型的变量一定没有属性和方法。
        原始类型的变量使用属性和方法时，系统会根据该变量的类型，隐式的new一个对象，将变量放在括号中。
        然后删除该对象，此时该变量从引用类型又变成了原始类型。
        例如：
              var str = 'abc';
              str.aaa = 123;
              //系统隐式的创建 new String(str)然后new String(str).aaa = 123;
              //如果该对象没有aaa属性，相当于在该对象中新增属性和属性值，但是最后删除new String('abc').aaa = 123;
              //此时访问str还是'abc'.
              console.log(str.aaa);
              //此时又遇到了原始值使用属性或方法，又继续创建一个对象new String(str),
              //然后访问new String(str)的aaa方法，但是该对象及其原型链中没有这个方法，所以返回undefined。
        比如：
              var str = 'abcd';  str.length = 2 ;
              // 当系统识别到原始数据类型使用方法或属性时，内部隐式的创建一个对象
              //var str = new String('abcd').length = 2;
               //创建完后，系统就销毁这个对象
              当再次访问str时，str不再是一个对象类型，而是一个原始类型。
              当再次访问str.length时，如果str时String类型，则是字符串长度，另外两种类型则是undefined。
————————————————————————————————————————————————————————————
拓展
     var a = 对象.方法；和 对象.方法();的区别：前者是将对象中的方法体保存在a变量并放在全局下，后者是调用该方法。
     方法直接执行和方法被调用的区别：前者走预编译环节this指向全局，后者this指向调用者。

    使用对象字面量创建对象而不是用构造函数创建对象的原因：
               对象字面量：强调该对象仅仅是一个可变的哈希映射，没有作用域解析
         构造函数创建对象：强调属性和方法是从对象中调用出来的，查寻作用域链直到全局Object构造函数。



