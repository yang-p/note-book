函数的简单概念:   函数和变量没什么区别，它和数组、对象一样都只是一个引用值。
函数的作用： 高内聚，弱耦合  将实现相同功能的代码封装在一个盒子里面，其他重复的代码删除。

函数的定义
    函数的声明(两种方式：函数声明、函数表达式)
              命名无参函数声明           function myFunction () {}
              命名有参函数声明   function myFun(形参1 ，形参2 ，...,形参n) {}
              命名不定参函数声明 function myFunction () {} //函数在调用时，根据需要传实参的个数
    函数表达式
              命名函数表达式         var fun = function fun() {}
              [匿名]函数表达式       var myFun = function (){}
    有参函数的特性：   形参相当于在函数体里面声明变量而不赋值。
              JavaScript有个特性，实参和形参不需要个数一致，并且实参值可以是任意类型。
              当形参个数小于实参个数时，多余的实参就不起作用，
              当形参的个数大于实参个数，多余的形参为undefined。
              调用实参的长度用arguments.length ,而调用形参的长度则是该函数的函数名，如 myFunction.length。

【在每一个函数里面都有一个类数组arguments，它将所有的实参存在里面】
【arguments中的实参值和函数的形参有一个映射规则】
              不论形参多还是实参多，多的那些实参或形参都属于没有建立映射关系。
              在形成了映射关系中的实参和形参中，无论是改变实参的值还是对形参赋值，
              对应的那个形参或实参的值都会变成改变后的值,
              而没有形成映射的形参和实参中，若形参多，当多的那个形参赋值时，这个值不会添加到 arguments中，
              因为arguments是类数组，没有数组的方法。
   函数表达式的特性：
                   function myFun(){} (); 这种是无法执行的；
              函数表达式的实质是对函数声明的引用，函数表达式执行完后，它不再代表一个函数，比如"myFun();
             "表达式执行完后，“myfun”不再代表函数名,因为他是立即执行函数的另一种写法；函数声明是无法被执行符号识别；
             【只有表达式才会被系统的执行符号执行】
   return两个作用：
                 第一，中止函数，return后面的语句不执行直接跳出去； 第二，返回一个值，将一个值返回到函数外面。
                 【若函数里面没有return，则系统会默认隐式的在函数体尾部加一个return。】
————————————————————————————————————————————————————————————
I递归方法
         递归的运行效率很低，使用递归方法最典型的两个例子就是阶乘和斐波拉数列；
         递归的使用方法，先找规律，然后找出口(规律中的已知值，如阶乘的最后一位是1，且0！=1)
        阶乘：                             斐波拉数列：
               function jc(n){                 function fb(n){
               if
                               return fb(n-1) + fb(n - 2);
               }                                }
————————————————————————————————————————————————————————————
作用域[[scope]]和作用域链:  作用域中所存储的执行期上下文对象的集合，这个集合呈链式链接所以叫作用域链。
  作用域简介：  一个JS函数代表一个对象,当一个函数定义时就产生了[[scope]]属性，不可被访问的,仅供JS引擎存取。

           [[scope]]属性存储的是作用域链(scope chain)，作用域链假设是一个数组，里面存储的是指向AO、GO的地址。

           一个函数分为两种状态定义状态和执行状态，父函数的执行会触发直接子函数的定义(函数声明)，定义是在预编译之前。

           一个全局函数定义状态，作用域链里面只有GO，执行状态时，向作用域链中的GO前面插入一个自己的AO，
           同时其直接子函数成为定义状态，产生作用域，此时作用域里面存的是父函数执行状态的作用域链，
           当执行这个子函数时，子函数的状态变成执行状态，此时在定义状态时的作用域链的前面加上自己的AO，以此类推。
           注意点：
                  作用域链中的父级AO和GO都是同一个，它们被子函数共享。
                  函数每执行一次时，会创建一个新的独一无二的AO对象。
                  函数执行完后会销毁自己的AO对象，此时作用域链回到其定义状态即保存着上级的作用域链。
                  这里的销毁指的是删除指向AO对象的地址，因此这个AO对象仍被存储着。

             全局变量a  a的[[scope]]-->GO
             局部变量a  a的[[scope]]-->AO -->GO   GO从数组下标0变成数组下标1，下标0被AO替代了；
                        当子函数执行时，子函数的a变量的[scope]链为 子函数的AO --> 父函数的AO --> GO,
                        依次类推，后代函数的作用域链是: [scope] 当前函数体的AO-->父函数的AO-->祖代AO-->第一代AO-->GO。
                    子函数预编译的scope引用它的父函数执行后的AO地址。
————————————————————————————————————————————————————————————
实现一个对象中，方法的连续调用：
         在每个方法的尾部写上 return this；












